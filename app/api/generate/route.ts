/**
 * AI Image Generation API Endpoint
 * POST /api/generate
 * Uses Google GenAI SDK (Gemini Imagen) for image generation
 */

import { NextRequest, NextResponse } from 'next/server';
import { GoogleGenAI } from '@google/genai';
import { enhancePrompt, validatePrompt } from '@/lib/prompts';
import type { Engine, Era } from '@/lib/prompts';

// Map aspect ratios to Gemini format
const aspectRatioMap: Record<string, string> = {
  '1:1': '1:1',
  '16:9': '16:9',
  '9:16': '9:16',
  '4:3': '4:3',
  '3:4': '3:4',
};

// Map quality to image size
const imageSizeMap = {
  standard: '1K', // 1024x1024 or equivalent
  hd: '4K', // 4096x4096 or equivalent
};

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { engine, prompt, era, aspectRatio, quality } = body;

    // Validate inputs
    if (!engine || !['rewind', 'refract', 'foresee'].includes(engine)) {
      return NextResponse.json(
        { error: 'Invalid engine. Must be rewind, refract, or foresee' },
        { status: 400 }
      );
    }

    if (!prompt) {
      return NextResponse.json(
        { error: 'Prompt is required' },
        { status: 400 }
      );
    }

    // Validate prompt
    const validation = validatePrompt(prompt);
    if (!validation.valid) {
      return NextResponse.json(
        { error: validation.error },
        { status: 400 }
      );
    }

    // Check API key
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey || apiKey === 'your_gemini_api_key_here') {
      return NextResponse.json(
        {
          error: 'GEMINI_API_KEY not configured',
          details: 'Please set GEMINI_API_KEY in your .env.local file with a valid Gemini API key',
        },
        { status: 500 }
      );
    }

    // Enhance prompt based on engine and settings
    const { prompt: enhancedPrompt } = enhancePrompt({
      userPrompt: prompt,
      engine: engine as Engine,
      era: era as Era,
      quality: quality || 'standard',
      aspectRatio,
    });

    console.log('Enhanced prompt:', enhancedPrompt);
    console.log('Aspect ratio:', aspectRatio);
    console.log('Quality:', quality);

    // Initialize Google GenAI
    const ai = new GoogleGenAI({
      apiKey,
    });

    // Configure image generation
    const config = {
      imageConfig: {
        aspectRatio: aspectRatioMap[aspectRatio || '1:1'] || '1:1',
        imageSize: imageSizeMap[quality as keyof typeof imageSizeMap] || '1K',
      },
      responseModalities: ['IMAGE'] as const,
    };

    const model = 'gemini-3-pro-image-preview';
    const contents = [
      {
        role: 'user' as const,
        parts: [
          {
            text: enhancedPrompt,
          },
        ],
      },
    ];

    console.log('Generating image with Gemini...');

    // Generate image
    const response = await ai.models.generateContentStream({
      model,
      config,
      contents,
    });

    // Collect image data from stream
    let imageBuffer: Buffer | null = null;
    let mimeType = 'image/png';

    for await (const chunk of response) {
      if (!chunk.candidates || !chunk.candidates[0].content || !chunk.candidates[0].content.parts) {
        continue;
      }

      if (chunk.candidates?.[0]?.content?.parts?.[0]?.inlineData) {
        const inlineData = chunk.candidates[0].content.parts[0].inlineData;
        mimeType = inlineData.mimeType || 'image/png';
        imageBuffer = Buffer.from(inlineData.data || '', 'base64');
        console.log('Image received:', mimeType, imageBuffer.length, 'bytes');
        break; // Take first image
      }
    }

    if (!imageBuffer) {
      throw new Error('No image generated by Gemini');
    }

    // Convert to base64 data URL
    const base64Image = imageBuffer.toString('base64');
    const imageUrl = `data:${mimeType};base64,${base64Image}`;

    const generationId = `gen_${Date.now()}_${Math.random().toString(36).substring(7)}`;

    // Return generated image with metadata
    return NextResponse.json({
      success: true,
      imageUrl,
      metadata: {
        engine,
        prompt: prompt.trim(),
        enhancedPrompt,
        era: era || 'realistic',
        timestamp: new Date().toISOString(),
        generationId,
        mimeType,
        size: imageBuffer.length,
      },
    });

  } catch (error) {
    console.error('Generation error:', error);

    // Handle specific error types
    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        return NextResponse.json(
          {
            error: 'Invalid API key',
            details: 'Please check your GEMINI_API_KEY is valid and has access to Imagen models',
          },
          { status: 500 }
        );
      }

      if (error.message.includes('quota') || error.message.includes('limit')) {
        return NextResponse.json(
          {
            error: 'API quota exceeded',
            details: 'Please check your Gemini API quota limits',
          },
          { status: 429 }
        );
      }
    }

    return NextResponse.json(
      {
        error: 'Failed to generate image',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

// GET method not allowed
export async function GET() {
  return NextResponse.json(
    { error: 'Method not allowed. Use POST to generate images.' },
    { status: 405 }
  );
}
